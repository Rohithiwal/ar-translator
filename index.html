<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Translator</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #111827; color: #F3F4F6; display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 16px; margin: 0; }
        h1 { font-size: 2.25rem; font-weight: bold; margin-bottom: 1rem; }
        #toggleButton { background-color: #10B981; color: white; font-size: 1rem; font-weight: bold; padding: 0.75rem 1.5rem; border: none; border-radius: 0.5rem; cursor: pointer; margin-bottom: 1rem; }
        #toggleButton.stop { background-color: #EF4444; }
        #canvas-container { width: 100%; max-width: 896px; margin: 0 auto; background-color: #1F2937; border-radius: 0.5rem; }
        canvas { max-width: 100%; width: 100%; height: auto; background-color: #000; border-radius: 0.5rem; }
        #status { margin-top: 1rem; color: #FCD34D; }
        video { display: none; }
    </style>
</head>
<body>
    <h1>Real-time AR Translator</h1>
    <button id="toggleButton">Start Camera</button>
    <div id="canvas-container"><canvas id="canvas"></canvas></div>
    <p id="status">Click "Start Camera" to begin.</p>
    <video id="video" playsinline autoplay muted></video>

    <script>
        // --- FIXED: Automatically uses the AWS Public IP ---
        const BACKEND_URL = window.location.origin + "/translate/"; 
        
        const PROCESSING_WIDTH = 800; 
        const PROCESS_EVERY_N_FRAMES = 30; // Increased to 30 for smoother CPU performance
        const FONT_SIZE = 18;
        
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const statusEl = document.getElementById('status');
        const toggleButton = document.getElementById('toggleButton');
        
        let frameCount = 0;
        let lastResults = [];
        let isProcessing = false;
        let currentStream = null;
        let animationFrameId = null;

        toggleButton.addEventListener('click', () => {
            if (currentStream) stopWebcam();
            else startWebcam();
        });

        async function startWebcam() {
            try {
                statusEl.innerText = "Starting webcam...";
                currentStream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1280 }, facingMode: 'environment' } });
                video.srcObject = currentStream;
                video.oncanplay = () => video.play();
                video.onloadedmetadata = () => {
                    canvas.width = PROCESSING_WIDTH;
                    canvas.height = PROCESSING_WIDTH * (video.videoHeight / video.videoWidth);
                    statusEl.innerText = "Webcam active.";
                    toggleButton.innerText = "Stop Camera";
                    toggleButton.classList.add("stop");
                    processFrame(); 
                };
            } catch (err) {
                console.error(err);
                statusEl.innerText = "Error: " + err.name;
            }
        }

        function stopWebcam() {
            if (!currentStream) return;
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            statusEl.innerText = "Webcam off.";
            toggleButton.innerText = "Start Camera";
            toggleButton.classList.remove("stop");
        }

        async function processFrame() {
            if (!currentStream) return;
            if (video.readyState < 2 || video.paused) {
                animationFrameId = requestAnimationFrame(processFrame);
                return;
            }
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            frameCount++;
            if (frameCount % PROCESS_EVERY_N_FRAMES === 0 && !isProcessing) getTranslation();
            drawResults();
            animationFrameId = requestAnimationFrame(processFrame);
        }

        async function getTranslation() {
            isProcessing = true;
            statusEl.innerText = "Translating...";
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const formData = new FormData();
                formData.append("file", blob, "frame.png");
                const response = await fetch(BACKEND_URL, { method: "POST", body: formData });
                if (!response.ok) throw new Error("Backend Error");
                lastResults = await response.json();
                if (currentStream) statusEl.innerText = "Webcam active.";
            } catch (err) { console.error(err); } 
            finally { isProcessing = false; }
        }

        function drawResults() {
            for (const res of lastResults) {
                ctx.fillStyle = "black";
                ctx.fillRect(res.tl[0], res.tl[1], res.br[0]-res.tl[0], res.br[1]-res.tl[1]);
                ctx.fillStyle = "pink";
                ctx.font = "18px Arial";
                ctx.fillText(res.text, res.tl[0]+2, res.tl[1]+18);
            }
        }
    </script>
</body>
</html>